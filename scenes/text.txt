A 0.2 255,255,255 // (intensity, color)
C -10.0,0,20 0,0,1 70 //(Camera position (x,y,z), Camera orientation vector, Field of view in degrees)
L -40.0,50.0,0.0 0.6 255,255,255 //(Light position (x,y,z), Light intensity 0 1, Light color)
sp 0.0,0.0,20.6 12.6 255,0,0 //(Sphere position (x,y,z), Sphere diameter, Sphere color)

pl 0.0,0.0,-10.0 0.0,1.0,0.0 0,0,225
pl 0.0,-1.0,0.0 0.0,1.0,0.0 0,0,225 // ok

//ok
C 0,0,-10 0,0,1 70
L -5,10,-4 0.9 255,255,255
A 0.1 220,220,255
sp 0,0,0 5 255,0,0 0
pl 0,-5.5,0 0,0.8,0.2 0,255,0 0.3
pl 8, 0, 0 -1, 0, 0 255,255,0
pl 0, 0, 45 0, 0, -1 0,0,255




# C 0,0,-10 0,0,1 70
# L -5,10,-4 0.9 255,255,255
# A 0.1 220,220,255
# sp 0,0,0 5 255,0,0 0
# pl 0,-5.5,0 0,0.8,0.2 0,255,0 0.3
# pl 8, 0, 0 -1, 0, 0 255,255,0
# pl 0, 0, 45 0, 0, -1 0,0,255


// perfect

C 0,0,-10 0,0,1 70
L -2,3,-8 0.9 255,255,255
A 0.2 220,220,255
sp 0,-1.7,0 5 255,0,0 0
pl 0,-5.5,0 0,1,0 0,255,0 0.3
pl 8,0,0 -1,0,0 255,255,0
pl 0,0,45 0,0,-1 0,0,255


//perfect 2
C 5,10,-25 -0.2,-0.3,0.8 50
L -2,3,-10 0.6 255,255,255
A 0.2 220,220,255
sp -5,-2.5,10 7 255,0,0 0
pl 0,-5.5,0 0,1,0 0,255,0 0.3
pl 8,0,0 -1,0,0 255,255,0
pl 0,0,45 0,0,-1 0,0,255




// modify:

is_shadowed()
shade_hit()
lighting()
color_at()
intersect_world()
prepare_computations()


was working:

parser.c:

#include "minirt.h"

void	parse_ambient(char *line, t_scene *scene)
{
	char	**split;
	char	**color;

	split = ft_split(line, ' ');
	if (!split || !split[1] || !split[2])
	{
		fprintf(stderr, "Error: Invalid ambient light format\n");
		return ;
	}
	scene->ambient_intensity = ft_atof(split[1]);
	color = ft_split(split[2], ',');
	if (!color || !color[0] || !color[1] || !color[2])
	{
		fprintf(stderr, "Error: Invalid ambient light color format\n");
		ft_free_split(split);
		return ;
	}
	scene->ambient_color.r = ft_atof(color[0]) / 255.0;
	scene->ambient_color.g = ft_atof(color[1]) / 255.0;
	scene->ambient_color.b = ft_atof(color[2]) / 255.0;
	ft_free_split(split);
	ft_free_split(color);
}

void	parse_camera(char *line, t_scene *scene)
{
	char	**split;
	char	**pos;
	char	**orient;

	split = ft_split(line, ' ');
	if (!split || !split[1] || !split[2] || !split[3])
	{
		fprintf(stderr, "Error: Invalid camera format\n");
		return ;
	}
	pos = ft_split(split[1], ',');
	orient = ft_split(split[2], ',');
	if (!pos || !pos[0] || !pos[1] || !pos[2] || !orient || !orient[0]
		|| !orient[1] || !orient[2])
	{
		fprintf(stderr,
			"Error: Invalid camera position or orientation format\n");
		ft_free_split(split);
		return ;
	}
	scene->camera.position = create_point(ft_atof(pos[0]), ft_atof(pos[1]),
			ft_atof(pos[2]));
	scene->camera.orientation = create_vector(ft_atof(orient[0]),
			ft_atof(orient[1]), ft_atof(orient[2]));
	scene->camera.fov = ft_atof(split[3]);
	ft_free_split(split);
	ft_free_split(pos);
	ft_free_split(orient);
}

void	parse_light(char *line, t_scene *scene)
{
	char	**split;
	char	**pos;
	char	**color;

	split = ft_split(line, ' ');
	if (!split || !split[1] || !split[2] || !split[3])
	{
		fprintf(stderr, "Error: Invalid light format\n");
		return ;
	}
	pos = ft_split(split[1], ',');
	if (!pos || !pos[0] || !pos[1] || !pos[2])
	{
		fprintf(stderr, "Error: Invalid light position format\n");
		ft_free_split(split);
		return ;
	}
	// Set position using direct assignment
	scene->light.position.x = ft_atof(pos[0]);
	scene->light.position.y = ft_atof(pos[1]);
	scene->light.position.z = ft_atof(pos[2]);
	scene->light.position.w = 1.0; // Point light source
	// Set intensity directly
	scene->light.intensity = ft_atof(split[2]) * 1.2;
	// Set color
	color = ft_split(split[3], ',');
	if (!color || !color[0] || !color[1] || !color[2])
	{
		fprintf(stderr, "Error: Invalid light color format\n");
		ft_free_split(split);
		ft_free_split(pos);
		return ;
	}
	// Set color components directly
	scene->light.color.r = ft_atof(color[0]);
	scene->light.color.g = ft_atof(color[1]);
	scene->light.color.b = ft_atof(color[2]);
	// Increment light count
	scene->light_count++;
	// Free allocated memory
	ft_free_split(split);
	ft_free_split(pos);
	ft_free_split(color);
}

void	parse_sphere(char *line, t_scene *scene)
{
	t_sphere	sphere;
	char		**split;
	char		**color;
	char		**pos;

	split = ft_split(line, ' ');
	if (!split || !split[1] || !split[2] || !split[3] || !split[4])
	{
		fprintf(stderr, "Error: Invalid sphere format\n");
		return ;
	}
	pos = ft_split(split[1], ',');
	if (!pos || !pos[0] || !pos[1] || !pos[2])
	{
		fprintf(stderr, "Error: Invalid sphere position format\n");
		ft_free_split(split);
		return ;
	}
	sphere.center = create_point(ft_atof(pos[0]), ft_atof(pos[1]),
			ft_atof(pos[2]));
	sphere.radius = ft_atof(split[2]) / 2.0;
	color = ft_split(split[3], ',');
	if (!color || !color[0] || !color[1] || !color[2])
	{
		fprintf(stderr, "Error: Invalid sphere color format\n");
		ft_free_split(split);
		ft_free_split(pos);
		return ;
	}
	sphere.material.color = create_color(ft_atof(color[0]) / 255.0,
			ft_atof(color[1]) / 255.0, ft_atof(color[2]) / 255.0);
	sphere.material.ambient = 0.1;
	sphere.material.diffuse = 0.9;
	sphere.material.specular = 0.8;
	sphere.material.shininess = 200;
	sphere.material.reflective = 0.0;
	add_sphere(scene, &sphere);
	ft_free_split(split);
	ft_free_split(pos);
	ft_free_split(color);
}

void	parse_plane(char *line, t_scene *scene)
{
	t_plane	plane;
	char	**split;
	char	**pos;
	char	**normal;
	char	**color;
	t_tuple	point;
	t_tuple	norm;
	t_color	col;

	split = ft_split(line, ' ');
	if (!split || !split[1] || !split[2] || !split[3])
	{
		fprintf(stderr, "Error: Invalid plane format\n");
		return ;
	}
	pos = ft_split(split[1], ',');
	normal = ft_split(split[2], ',');
	color = ft_split(split[3], ',');
	if (!pos || !pos[0] || !pos[1] || !pos[2] || !normal || !normal[0]
		|| !normal[1] || !normal[2] || !color || !color[0] || !color[1]
		|| !color[2])
	{
		fprintf(stderr, "Error: Invalid plane parameters format\n");
		ft_free_split(split);
		if (pos)
			ft_free_split(pos);
		if (normal)
			ft_free_split(normal);
		if (color)
			ft_free_split(color);
		return ;
	}
	point = create_point(ft_atof(pos[0]), ft_atof(pos[1]), ft_atof(pos[2]));
	norm = create_vector(ft_atof(normal[0]), ft_atof(normal[1]),
			ft_atof(normal[2]));
	col = create_color(ft_atof(color[0]) / 255.0, ft_atof(color[1]) / 255.0,
			ft_atof(color[2]) / 255.0);
	plane = create_plane(point, norm, col);
	plane.material.ambient = 0.15;
	plane.material.diffuse = 0.8;
	plane.material.specular = 0.2;
	plane.material.shininess = 150;
	add_plane(scene, &plane);
	ft_free_split(split);
	ft_free_split(pos);
	ft_free_split(normal);
	ft_free_split(color);
}

void	parse_scene(const char *filename, t_scene *scene)
{
	FILE	*file;
	char	line[256];
	char	*newline;

	file = fopen(filename, "r");
	if (!file)
	{
		fprintf(stderr, "Error: Could not open file %s\n ", filename);
		exit(1);
	}
	printf("File opened successfully, initializing scene\n");
	ft_memset(scene, 0, sizeof(t_scene));
	while (fgets(line, sizeof(line), file))
	{
		newline = strchr(line, '\n');
		if (newline)
			*newline = '\0';
		if (line[0] == '\n' || line[0] == '#' || line[0] == '\0'
			|| line[0] == ' ')
			continue ;
		printf("Parsing line: [%s]\n", line);
		if (line[0] == 'A')
			parse_ambient(line, scene);
		else if (line[0] == 'C')
			parse_camera(line, scene);
		else if (line[0] == 'L')
			parse_light(line, scene);
		else if (line[0] == 's' && line[1] == 'p')
			parse_sphere(line, scene);
		else if (line[0] == 'p' && line[1] == 'l')
			parse_plane(line, scene);
	}
	fclose(file);
	if (scene->sphere_count == 0 || scene->light_count == 0)
	{
		fprintf(stderr,
			"Error: Scene must contain at least one sphere and one light\n");
		exit(1);
	}
}

